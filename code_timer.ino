#include <Arduino.h>
/* 
  Sketch generated by the Arduino IoT Cloud Thing "Untitled 2"
  https://create.arduino.cc/cloud/things/9db1d149-ab40-4bd4-8c64-a4219c456402 

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  int roller_unwinder;
  int roller_winder;
  bool roller_moving;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/

#include "thingProperties.h"

#include "FspTimer.h"


#define PIN_WINDER_STEP 9
#define PIN_UNWINDER_STEP 6



FspTimer audio_timer;
uint64_t count=0;
uint64_t start_time=0;


uint8_t pinstate_winder = 0;
uint8_t pinstate_unwinder = 0;

// callback method used by timer
void timer_callback(timer_callback_args_t __attribute((unused)) *p_args) {
  pinstate_winder = !pinstate_winder;
  digitalWrite(6, pinstate_winder);
  pinstate_unwinder = !pinstate_unwinder;
  digitalWrite(5, pinstate_unwinder);
}

bool beginTimer(float rate) {
  uint8_t timer_type = GPT_TIMER;
  int8_t tindex = FspTimer::get_available_timer(timer_type);
  if (tindex < 0){
    tindex = FspTimer::get_available_timer(timer_type, true);
  }
  if (tindex < 0){
    return false;
  }

  FspTimer::force_use_of_pwm_reserved_timer();

  if(!audio_timer.begin(TIMER_MODE_PERIODIC, timer_type, tindex, rate, 0.0f, timer_callback)){
    return false;
  }

  if (!audio_timer.setup_overflow_irq()){
    return false;
  }

  if (!audio_timer.open()){
    return false;
  }

  if (!audio_timer.start()){
    return false;
  }
  return true;
}





void setup() {
  // Initialize serial and wait for port to open:
  Serial.begin(115200);
  // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  delay(1500); 

  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);
  
  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information youâ€™ll get.
     The default is 0 (only errors).
     Maximum is 4
 */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();


  
  // pinMode(PIN_WINDER_STEP, OUTPUT);
  // pinMode(PIN_UNWINDER_STEP, OUTPUT);


  beginTimer(2000);

}




int real_winding_speed = 0;
int real_unwind_speed = 0;
float precise_winding_speed = 0;
float precise_unwind_speed = 0;
#define STEPR_MAX_COUNT 1024

#define STEPER_MIN_MICROS 128
#define STEPR_ACTV_MICROS 64
int metering_cycle_WINDR_next_micros = 0;
int metering_cycle_WINDR_high_micros = 0;
int metering_cycle_WINDR_low_micros = 0;
int metering_cycle_UNWINDR_next_micros = 0;
int metering_cycle_UNWINDR_high_micros = 0;
int metering_cycle_UNWINDR_low_micros = 0;

bool update_cloud = true;
bool update_serial = true;

void loop() {
  
  if (millis() % 1000 < 3)
  {
    if (update_cloud)
    {
      ArduinoCloud.update();
      update_cloud = false;
      
      /*    
      if (real_winding_speed < 0 || STEPR_MAX_COUNT < real_winding_speed)
      {
        roller_moving = false;
        real_winding_speed = 0;
      }
      if (real_unwind_speed < 0 || STEPR_MAX_COUNT < real_unwind_speed)
      {
        roller_moving = false;
        real_unwind_speed = 0;
      }
    //*/
      real_winding_speed = roller_moving ? roller_winder * roller_winder : 0 ;
      real_unwind_speed = roller_moving ? roller_unwinder * roller_unwinder : 0 ;
      precise_winding_speed = roller_moving ? roller_winder / 10.0 : 0 ;
      precise_unwind_speed = roller_moving ? roller_unwinder / 10.0 : 0 ;
      
    }
  }
  else 
  {
    update_cloud = true;
  }
  // Your code here 


  
  if (millis() % 5000 == 0)
  {
    if (update_serial)
    {
      Serial.print("roller_moving: "); Serial.print(roller_moving); Serial.print(" \troller_unwinder: "); Serial.print(real_unwind_speed);Serial.print(" \troller_winder: "); Serial.println(real_winding_speed);
      update_serial = false;
    }
  }
  else 
  {
    update_serial = true;
  }
  



}


/*
  Since RollerUnwinder is READ_WRITE variable, onRollerUnwinderChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onRollerUnwinderChange()  {
  // Add your code here to act upon RollerUnwinder change
}

/*
  Since RollerWinder is READ_WRITE variable, onRollerWinderChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onRollerWinderChange()  {
  // Add your code here to act upon RollerWinder change
}

/*
  Since RollerMoving is READ_WRITE variable, onRollerMovingChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onRollerMovingChange()  {
  // Add your code here to act upon RollerMoving change
}





