#include "arduino_secrets.h"
#include <Arduino.h>
/* 
  Sketch generated by the Arduino IoT Cloud Thing "Untitled 2"
  https://create.arduino.cc/cloud/things/9db1d149-ab40-4bd4-8c64-a4219c456402 

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  int roller_unwinder;
  int roller_winder;
  bool roller_moving;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/

#include "thingProperties.h"

#include "FspTimer.h"


#define PIN_WINDER_STEP 5
#define PIN_UNWINDER_STEP 6


typedef struct timer_ch_s 
{
  FspTimer timer;
  uint8_t type;
  float rate;
  int8_t index;
  GPTimerCbk_f (tfp);
} timer_ch_t;



volatile uint8_t pinstate_winder = 0;
volatile uint8_t pinstate_unwinder = 1;

// callback method used by timer
GPTimerCbk_f  timer_callback_a(timer_callback_args_t __attribute((unused)) *p_args) {
  pinstate_winder = !pinstate_winder;
  digitalWrite(6, pinstate_winder);
}
// callback method used by timer
GPTimerCbk_f timer_callback_b(timer_callback_args_t __attribute((unused)) *p_args) {
  pinstate_unwinder = !pinstate_unwinder;
  digitalWrite(5, pinstate_unwinder);
}


bool initTimer(timer_ch_t * timerch) 
{
  // Timer type gets called back 
  timerch->index = FspTimer::get_available_timer(timerch->type);
  if (timerch->index < 0){
    // Force acquisition of a timer 
    timerch->index = FspTimer::get_available_timer(timerch->type, true);
  }
  if (timerch->index < 0){
    return false;
  }

  FspTimer::force_use_of_pwm_reserved_timer();

  return true;
}

bool beginTimer(timer_ch_t * timerch) 
{

  if(!timerch->timer.begin(TIMER_MODE_PERIODIC, timerch->type, timerch->index, timerch->rate, 0.0f, timerch->tfp)){
    return false;
  }

  if (!timerch->timer.setup_overflow_irq()){
    return false;
  }

  if (!timerch->timer.open()){
    return false;
  }

  if (!timerch->timer.start()){
    return false;
  }
  return true;
}



timer_ch_t tim_a;
timer_ch_t tim_b;

void setup() {
  Serial.begin(115200);
  delay(1500); 
  Serial.println("initing");
  initProperties();
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();

  
  pinMode(PIN_WINDER_STEP, OUTPUT);
  pinMode(PIN_UNWINDER_STEP, OUTPUT);

  tim_a.rate = 4;
  tim_b.rate = 4;

  Serial.println("TIMER A INIT");
  Serial.println(initTimer(&tim_a));
  Serial.println(tim_a.index);
  tim_a.tfp = (GPTimerCbk_f)timer_callback_a;
  Serial.println("TIMER A BEGIN");
  Serial.println(beginTimer(&tim_a));

  Serial.println("TIMER B INIT");
  Serial.println(initTimer(&tim_b));
  Serial.println(tim_b.index);
  tim_b.tfp = (GPTimerCbk_f)timer_callback_b;
  Serial.println("TIMER B BEGIN");
  Serial.println(beginTimer(&tim_b));
  Serial.println("timer initial start");

  delay(1000);
}



int last_winding_speed = 0;
int last_unwind_speed = 0;
int timers_on = 0;
int real_winding_speed = 0;
int real_unwind_speed = 0;
float precise_winding_speed = 0;
float precise_unwind_speed = 0;
#define STEPR_MAX_COUNT 1024
#define STEPER_MIN_MICROS 128
#define STEPR_ACTV_MICROS 64

bool update_cloud = true;
bool update_serial = true;

void loop() {
  
  if (millis() % 300 < 3)
  {
    if (update_cloud)
    {
      
      Serial.println("cloud update");
      ArduinoCloud.update();
      update_cloud = false;
      
      /*    
      if (real_winding_speed < 0 || STEPR_MAX_COUNT < real_winding_speed)
      {
        roller_moving = false;
        real_winding_speed = 0;
      }
      if (real_unwind_speed < 0 || STEPR_MAX_COUNT < real_unwind_speed)
      {
        roller_moving = false;
        real_unwind_speed = 0;
      }
      //*/


      real_winding_speed = roller_moving ? roller_winder * roller_winder : 0 ;
      real_unwind_speed = roller_moving ? roller_unwinder * roller_unwinder : 0 ;
      precise_winding_speed = roller_moving ? roller_winder / 1.0 : 0 ;
      precise_unwind_speed = roller_moving ? roller_unwinder / 1.0 : 0 ;

      if (roller_moving && (!timers_on || last_winding_speed != roller_winder || last_unwind_speed != roller_unwinder))
      {

        Serial.println("roller moving and setting speed");
        last_unwind_speed = roller_unwinder;
        last_winding_speed = roller_winder;
        timers_on = true;


        Serial.println("ENDING timer A");
        tim_a.timer.end();
        Serial.println("ENDING timer B");
        tim_b.timer.end();
        
        
        Serial.println("change speed");
        tim_a.rate = real_winding_speed;
        tim_b.rate = real_unwind_speed;

        Serial.println("starting timer A");
        beginTimer(&tim_a);
        Serial.println("starting timer B");
        beginTimer(&tim_b);
      }
      else if (!roller_moving && timers_on)
      {
        timers_on = false;
        Serial.println("closing A");
        tim_a.timer.end();
        Serial.println("closing B");
        tim_b.timer.end();
      }

      
    }
  }
  else 
  {
    update_cloud = true;
  }
  // Your code here 


  
  if (millis() % 500 == 0)
  {
    if (update_serial)
    {
      Serial.print("roller_moving: "); Serial.print(roller_moving); Serial.print(" \troller_unwinder: "); Serial.print(real_unwind_speed);Serial.print(" \troller_winder: "); Serial.println(real_winding_speed);
      update_serial = false;
    }
  }
  else 
  {
    update_serial = true;
  }



  delay(2);
}


/*
  Since RollerUnwinder is READ_WRITE variable, onRollerUnwinderChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onRollerUnwinderChange()  {
  // Add your code here to act upon RollerUnwinder change
}

/*
  Since RollerWinder is READ_WRITE variable, onRollerWinderChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onRollerWinderChange()  {
  // Add your code here to act upon RollerWinder change
}

/*
  Since RollerMoving is READ_WRITE variable, onRollerMovingChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onRollerMovingChange()  {
  // Add your code here to act upon RollerMoving change
}





